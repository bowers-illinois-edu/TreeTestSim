% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tree_test_sims.R
\name{get_level_info}
\alias{get_level_info}
\title{Compute Level and Offset Information for a k-ary Tree}
\usage{
get_level_info(k, l)
}
\arguments{
\item{k}{Integer; the branching factor (i.e., each internal node has \code{k} children). Must be greater than 0.}

\item{l}{Integer; the depth of the tree (0-based). If \code{l=0}, there is only a root. If l=1, this means a root and one level below the root.}
}
\value{
A list with the elements:
\describe{
\item{\code{k}{k}}
\item{\code{l}{l}}
\item{\code{level_sizes}}{An integer vector of length \code{l+1}, where \code{level_sizes[d+1] = k^d}.}
\item{\code{level_offsets}}{An integer vector of length \code{l+1}, where
\code{level_offsets[d+1]} is the total number of nodes up to (but not including) level \code{d}. Used for creating indices.}
\item{\code{n_tot}}{The total number of nodes in the tree, \eqn{\sum_{d=0}^{l} k^d}.}
}
}
\description{
Given a branching factor \code{k} and a depth \code{l}, this function
computes the number of nodes at each level and the starting offsets for a
level-by-level indexing scheme in a single vector.
}
\examples{
# For k=2, l=3, we have a binary tree of depth 3
info <- get_level_info(k = 2, l = 3)
info$level_sizes # c(1, 2, 4, 8)
info$level_offsets # c(0, 1, 3, 7)
# Index of root is 0 in a 0-based system (we go between 0-based for mathematical clarity and 1-based for R
# Here we show both:
# for 1-based indexing the next level l=1 is level_offsets[2]+c(1,2)=c(2,3)
# for 0-based indexing the next level l=1 is level_offsets[2]+c(0,1)=c(1,2)
# For the next level, l=2 (or the third level in the tree if you are counting the root as a level)
# for the first node in level 1 the children in level 2 using: 1-based indexing level_offsets[3] + c(1,2)=c(4,5)
# for the second node in level 1 the children in level 2  1-based indexing level_offsets[3] + c(k*(2-1)+1,k*(2-1)+2) = 3+c(3,4)=c(6,7)
# for the first node in level 1 the children in level 2 0-based indexing level_offsets[3] + seq(k*j,k*j+(k-1))=3+c(0,1)=c(3,4)
# for the second node in level 1 the children in level 2 0-based indexing level_offsets[3] + seq(k*j,k*j + (k-1))=3+c(2,3)=c(5,6)
info$n_tot # 15 total nodes

}
