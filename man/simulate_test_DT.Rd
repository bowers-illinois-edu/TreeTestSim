% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_test.R
\name{simulate_test_DT}
\alias{simulate_test_DT}
\title{Simulate the Testing Procedure on a k-ary Tree with Optional Alpha Spending/Investing}
\usage{
simulate_test_DT(
  treeDT,
  alpha,
  k,
  effN,
  N_total,
  beta_base,
  adj_effN = TRUE,
  local_adj_p_fn = local_simes,
  global_adj = "hommel",
  alpha_method = "fixed",
  return_details = TRUE,
  final_global_adj = "none",
  monotonicity = TRUE,
  delta_hat = NULL,
  tau = 0.1
)
}
\arguments{
\item{treeDT}{A data.table as produced by \code{generate_tree_DT()}.}

\item{alpha}{Numeric. The nominal significance level.}

\item{k}{Integer. The branching factor.}

\item{effN}{Numeric. The effective sample size at the root.}

\item{N_total}{Numeric. The total sample size at the root.}

\item{beta_base}{Numeric. The base parameter for the beta distribution.}

\item{adj_effN}{Logical. Whether to adjust the effective sample size at deeper levels.}

\item{local_adj_p_fn}{Function. A function that adjusts p-values at a node (e.g. \code{local_simes}).}

\item{global_adj}{Character. The method to adjust the leaves (e.g. "hommel").}

\item{alpha_method}{Character. One of \code{"fixed"}, \code{"spending"},
\code{"investing"}, \code{"fixed_k_adj"}, \code{"adaptive_k_adj"}, or
\code{"adaptive_power"}. The \code{"adaptive_power"} method uses
\code{\link[manytestsr]{compute_adaptive_alphas}} to precompute a
depth-indexed alpha schedule based on estimated power decay through the
tree.}

\item{return_details}{Logical. Whether to return the full simulated data.table.}

\item{final_global_adj}{Character. One of \code{"none"}, \code{"fdr"}, \code{"fwer"}.}

\item{monotonicity}{Logical. TRUE if we require child nodes p-values to be
no larger than those of parent nodes. FALSE child nodes could have smaller
p-values.}

\item{delta_hat}{Numeric or NULL. Estimated standardized effect size for
\code{alpha_method = "adaptive_power"}. If NULL (default), derived
automatically from \code{beta_base} and \code{N_total} by matching root
power. Ignored for other alpha methods.}

\item{tau}{Numeric. Cumulative power threshold for
\code{alpha_method = "adaptive_power"} (default 0.1). When cumulative
power drops below tau, natural gating is deemed sufficient and nominal
alpha is used. Ignored for other alpha methods.}
}
\value{
A list with components:
\describe{
\item{treeDT}{The data.table augmented with columns \code{p_val} and \code{alpha_alloc}.}
\item{sim_res}{A data.table summarizing error rates and discoveries.}
}
}
\description{
This version of the simulation procedure incorporates an extra option for how the
significance level is allocated along the tree. The user may choose:
\itemize{
\item \code{"fixed"}: use the same significance level α at every node (as before),
\item \code{"spending"}: at each branch the available α is reduced by a fixed fraction,
\item \code{"investing"}: a simple α–investing scheme where rejections earn a bonus.
}

In this implementation an extra column \code{alpha_alloc} is added to each node.
The root is allocated the full α. Then, if a node is “active” (i.e. its p-value is below
its allocated threshold) its children are tested at a level that depends on the chosen method:
\itemize{
\item For \code{"fixed"}, each child inherits the full α,
\item For \code{"fixed_k_adj"}, each child is tested at \code{alpha/(1+alpha k)} which should be conservative,
\item For \code{"adaptive_k_adj"}, each child is tested at \code{parent_p + (1-parent_p)(alpha/k)} which should be conservative,
\item For \code{"spending"}, the children are tested at level \code{parent_alpha + max((alpha-parent_p),0)/k},
\item For \code{"investing"}, the children are tested at level \code{parent_alpha + max((parent_alpha-parent_p),0)/k}.
}
}
\examples{
dt <- generate_tree_DT(max_level = 3, k = 3, t = 0.2)
res <- simulate_test_DT(dt,
  alpha = 0.05, k = 3, effN = 1000, N_total = 1000,
  beta_base = 0.1, alpha_method = "spending", return_details = TRUE
)
}
